<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>limegle</title>
<link rel="icon" href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><text x="4" y="12">l</text></svg>'>
<script src="/env.js"></script>
<script src="https://unpkg.com/@supabase/supabase-js@2.45.4/dist/umd/supabase.js"></script>
<style>
  :root { --header-h: 48px; }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0}
  body{display:flex;flex-direction:column;font-family:monospace;color:#000;background:#fff;overflow:hidden}

  /* Header centered: call — limegle — help; id on right */
  header{
    height:var(--header-h);
    display:grid;grid-template-columns:1fr auto 1fr;
    align-items:center;padding:6px 8px;border-bottom:1px solid #000
  }
  header h1{grid-column:2;margin:0;font-size:22px;line-height:1}
  header a{justify-self:center;color:#00f;text-decoration:underline;line-height:1}
  .right-id{grid-column:3;justify-self:end;font-size:12px;line-height:1}

  /* Main layout */
  main{height:calc(100vh - var(--header-h));display:grid;grid-template-columns:2fr 1fr;gap:8px;padding:8px}
  @media (max-width:900px){ main{grid-template-columns:1fr} }

  /* Videos column: two equal rows */
  section.videos{display:grid;grid-template-rows:1fr 1fr;border-right:1px solid #000;min-height:0}
  .box{position:relative;border-bottom:1px solid #000;display:flex;flex-direction:column;min-height:0}
  .box:last-child{border-bottom:none}

  /* Video letterbox logic:
     - default: grey with loader (no stream)
     - when stream attached -> .has-video => black bars */
  video{flex:1;width:100%;height:100%;object-fit:contain;background:#ccc url('https://i.stack.imgur.com/kOnzy.gif') center/40px no-repeat}
  video.has-video{background:#000}

  .label{position:absolute;left:4px;top:2px;font-size:12px;background:#fff;padding:0 2px}
  .ribbon{position:absolute;left:4px;bottom:2px;font-size:12px;padding:0 2px}

  /* Controls on right; remote indicators are spans */
  .controls{position:absolute;right:4px;top:4px;display:flex;gap:6px;align-items:center}
  .controls span{font-size:12px;pointer-events:none}
  button{font-size:12px}

  /* Chat column */
  aside.chat{display:flex;flex-direction:column;min-height:0}
  .chat-header{border-bottom:1px solid #000;padding:4px;font-weight:bold}
  .chat-log{flex:1;overflow:auto;padding:4px;min-height:0}
  .chat-input{display:flex;gap:6px;border-top:1px solid #000;padding:4px}
  .chat-input input{flex:1;min-width:0}
  .chat-input form, .chat-input{margin:0}

  /* Join overlay */
  #joinCta{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(255,255,255,.85)}
  #joinCta .joinbox{border:1px solid #000;padding:16px 20px;background:#fff;cursor:pointer;text-align:center}

  /* header: center the group tightly, ID flush-right, all vertically centered */
  header{
    height:48px;
    display:grid;
    grid-template-columns:1fr auto 1fr;
    align-items:center;
    padding:6px 8px;
    border-bottom:1px solid #000;
  }
  .center-group{
    grid-column:2;
    justify-self:center;
    display:flex;
    align-items:center;
    gap:10px;            /* reduce or increase spacing */
  }
  .center-group h1{ margin:0; font-size:22px; line-height:1; }
  .center-group a{ color:#00f; text-decoration:underline; line-height:1; }
  .right-id{ grid-column:3; justify-self:end; font-size:12px; line-height:1; }



  :root { --header-h: 72px; } /* adjust if you want more/less header height */

  /* two-row header */
  header{
    height: var(--header-h);
    display: grid;
    grid-template-columns: 1fr auto 1fr; /* left | center | right */
    grid-template-rows: 24px 1fr;        /* row 1: status strip, row 2: main */
    align-items: center;
    padding: 4px 8px;
    border-bottom: 1px solid #000;
  }
  
  /* row 2: main title/links centered */
  .center-group{
    grid-column: 2;
    grid-row: 2;
    justify-self: center;
    display: flex;
    align-items: center;
    gap: 10px;
  }
  
  /* row 1: left + right status */
  .left-online{
    grid-column: 1;
    grid-row: 1;
    justify-self: start;
    font-size: 12px;
    line-height: 1;
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .left-online-dot{
    width: 8px; height: 8px; border-radius: 50%;
    background: #0aa;
  }
  .right-id{
    grid-column: 3;
    grid-row: 1;
    justify-self: end;
    font-size: 12px;
    line-height: 1;
  }
  
  /* row 1: centered disclaimer */
  .disclaimer{
    grid-column: 2;
    grid-row: 1;
    justify-self: center;
    font-size: 14px;
    line-height: 1;
    color: #ff0f0f;
    letter-spacing: .2px;
    font-weight: bold;
    pointer-events: none;  /* don't block clicks on links */
  }
  
  @media (max-width:600px){
    .disclaimer{ font-size: 12px; }
  }
</style>
</head>
<body>
<header>
  <div class="center-group">
    <a href="#" id="callLink">call</a>
    <h1>limegle</h1>
    <a href="#" id="helpLink">help</a>
  </div>
  <div class="right-id">user id: <span id="userId">—</span></div>
  <div class="left-online">
    <span class="left-online-dot" aria-hidden="true"></span>
    <span>online: <span id="onlineCount">0</span></span>
  </div>
  <div class="disclaimer" role="note" aria-label="disclaimer">
    disclaimer: use responsibly and when permitted to do so
  </div>
</header>

<main>
  <!-- videos -->
  <section class="videos">
    <!-- remote -->
    <div class="box" id="remoteTile">
      <span class="label" id="remoteLabel">person</span>
      <video id="remoteVideo" autoplay playsinline></video>
      <div class="controls">
        <span id="remoteMicInd"></span>
        <span id="remoteCamInd"></span>
        <button id="skipBtn" type="button">skip</button>
      </div>
      <div class="ribbon" id="remoteRibbon"></div>
    </div>

    <!-- local -->
    <div class="box" id="localTile">
      <span class="label" id="localLabel">you</span>
      <video id="localVideo" autoplay playsinline muted></video>
      <div class="controls">
        <button id="toggleMic" type="button">mic</button>
        <button id="toggleCam" type="button">cam</button>
      </div>
      <div class="ribbon" id="localRibbon"></div>
    </div>
  </section>

  <!-- chat -->
  <aside class="chat">
    <div class="chat-header">text chat</div>
    <div id="chatLog" class="chat-log"></div>
    <form id="chatForm" class="chat-input" autocomplete="off">
      <input id="chatText" placeholder="type a message..." />
      <button type="submit">send</button>
    </form>
  </aside>
</main>

<!-- join overlay -->
<div id="joinCta" role="button" tabindex="0">
  <div class="joinbox">
    TAP TO JOIN PUBLIC CHAT
    <div style="font-size:12px;margin-top:4px">press here to call</div>
  </div>
</div>

<script>
/* global supabase, ENV */
(() => {
  // elements
  const els = {
    userId: document.getElementById('userId'),
    remoteVideo: document.getElementById('remoteVideo'),
    localVideo: document.getElementById('localVideo'),
    remoteLabel: document.getElementById('remoteLabel'),
    localLabel: document.getElementById('localLabel'),
    localRibbon: document.getElementById('localRibbon'),
    remoteRibbon: document.getElementById('remoteRibbon'),
    remoteMicInd: document.getElementById('remoteMicInd'),
    remoteCamInd: document.getElementById('remoteCamInd'),
    toggleMic: document.getElementById('toggleMic'),
    toggleCam: document.getElementById('toggleCam'),
    skipBtn: document.getElementById('skipBtn'),
    chatLog: document.getElementById('chatLog'),
    chatForm: document.getElementById('chatForm'),
    chatText: document.getElementById('chatText'),
    joinCta: document.getElementById('joinCta'),
    onlineCount: document.getElementById('onlineCount')
  };

  // id
  const uid = (() => {
    const k = 'limegle_uid';
    let v = localStorage.getItem(k);
    if (!v) {
      v = (crypto.getRandomValues(new Uint32Array(1))[0] >>> 0)
        .toString(36)
        .slice(-6);
      localStorage.setItem(k, v);
    }
    return v;
  })();
  els.userId.textContent = uid;

  // supabase client
  const sb = supabase.createClient(ENV.SUPABASE_URL, ENV.SUPABASE_ANON_KEY);
  const mm = sb.channel('limegle-mm', { config: { presence: { key: uid }, broadcast: { self: false } } });
  mm.on('presence', { event: 'sync' }, onPresenceSync);
  mm.on('presence', { event: 'join' }, onPresenceSync);
  mm.on('presence', { event: 'leave' }, onPresenceSync);

  // rtc state
  let room = null, roomId = null;
  let pc = null, dc = null, localStream = null;
  let micOn = true, camOn = true;
  let remoteMicOn = null, remoteCamOn = null;
  let peerReady = false, sentOffer = false, userInteracted = false;
  let peerId = null, didRestartIce = false, wasSkipped = false, iSkipped = false, retryTimer = null;
  let handshakeTimer = null; // NEW

  const ICE_SERVERS =
    ENV.ICE_SERVERS && ENV.ICE_SERVERS.length
      ? ENV.ICE_SERVERS
      : [{ urls: 'stun:stun.l.google.com:19302' }];

  // chat helpers
  function pushSystem(text) {
    const row = document.createElement('div');
    row.textContent = text;
    els.chatLog.appendChild(row);
    els.chatLog.scrollTop = els.chatLog.scrollHeight;
  }
  function pushUserLine(id, text) {
    const row = document.createElement('div');
    row.textContent = `${id}: ${text}`;
    els.chatLog.appendChild(row);
    els.chatLog.scrollTop = els.chatLog.scrollHeight;
  }
  function clearChat() {
    els.chatLog.textContent = '';
  }

  // labels
  function labelWithState(name, mic, cam) {
    const bits = [];
    if (mic === false) bits.push('muted');
    if (cam === false) bits.push('camera off');
    return bits.length ? `${name} (${bits.join(' and ')})` : name;
  }
  function updateLocalLabel() {
    els.localLabel.textContent = labelWithState('you', micOn, camOn);
    const bits = [];
    if (!micOn) bits.push('mic off');
    if (!camOn) bits.push('camera off');
    els.localRibbon.textContent = bits.join(', ');
  }
  function updateRemoteState() {
    els.remoteLabel.textContent = labelWithState('person', remoteMicOn, remoteCamOn);
    els.remoteMicInd.textContent =
      remoteMicOn === null ? '' : `mic: ${remoteMicOn ? 'on' : 'off'}`;
    els.remoteCamInd.textContent =
      remoteCamOn === null ? '' : `cam: ${remoteCamOn ? 'on' : 'off'}`;
    const parts = [];
    if (remoteMicOn === false) parts.push('mic off');
    if (remoteCamOn === false) parts.push('camera off');
    els.remoteRibbon.textContent = parts.join(', ');
  }

  // media
  async function safeGetMedia() {
    try {
      localStream = await navigator.mediaDevices.getUserMedia({
        audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true },
        video: { width: { ideal: 640 }, height: { ideal: 360 }, frameRate: { ideal: 24, max: 30 } },
      });
      els.localVideo.srcObject = localStream;
      els.localVideo.classList.add('has-video');
      micOn = true; camOn = true;
    } catch (err) {
      micOn = false; camOn = false;
      updateLocalLabel();
      pushSystem('it looks like your camera/video is blocked.');
    }
    return localStream;
  }
  function applyLocalTrackState() {
    if (!localStream) return;
    const a = localStream.getAudioTracks()[0];
    const v = localStream.getVideoTracks()[0];
    if (a) a.enabled = !!micOn;
    if (v) v.enabled = !!camOn;
    updateLocalLabel();
  }
  function sendState() {
    if (dc && dc.readyState === 'open') {
      dc.send(JSON.stringify({ kind: 'state', mic: !!micOn, cam: !!camOn }));
    }
  }

  // webrtc
  function createPC(isCaller) {
    pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });

    pc.onicecandidate = (e) => {
      if (e.candidate)
        room?.send({ type: 'broadcast', event: 'signal', payload: { t: 'candidate', c: e.candidate } });
    };

    pc.ontrack = () => {
      // Use first stream (unified-plan)
      const recvStream = pc.getReceivers().find(r => r.track && r.track.kind === 'video')?.track?.kind
        ? null : null;
      // Attach the stream delivered by ontrack event
      // (most browsers send it in e.streams[0], but we already set it below)
    };

    pc.ontrack = (e) => {
      els.remoteVideo.srcObject = e.streams[0];
      els.remoteVideo.classList.add('has-video');
      // autoplay policy: unmute only after user gesture
      els.remoteVideo.muted = !userInteracted;
      Promise.resolve(els.remoteVideo.play()).catch(() => {});
      if (userInteracted) {
        els.remoteVideo.muted = false;
        Promise.resolve(els.remoteVideo.play()).catch(() => {});
      }
      remoteCamOn = true;
      updateRemoteState();
    };

    pc.onconnectionstatechange = async () => {
      const s = pc.connectionState;
      if (s === 'failed' && !didRestartIce) {
        didRestartIce = true;
        try { pc.restartIce(); } catch {}
        // If we were the caller, push a fresh ICE-restart offer
        try {
          if (isCaller) {
            const offer = await pc.createOffer({ iceRestart: true });
            await pc.setLocalDescription(offer);
            await room?.send({ type: 'broadcast', event: 'signal', payload: { t: 'offer', sdp: offer } });
          }
        } catch {}
        return;
      }
      if (s === 'failed' || s === 'disconnected' || s === 'closed') {
        cleanup(); // reason decided inside cleanup()
      }
    };

    if (isCaller) {
      dc = pc.createDataChannel('chat');
      attachDC();
    } else {
      pc.ondatachannel = (e) => {
        dc = e.channel;
        attachDC();
      };
    }
  }

  function attachDC() {
    dc.onopen = () => {
      if (handshakeTimer) { clearTimeout(handshakeTimer); handshakeTimer = null; } // NEW
      sendState();
      pushSystem(`connected with ${peerId || 'person'}`);
    };
    dc.onmessage = (e) => {
      try {
        const msg = JSON.parse(e.data);
        if (msg.kind === 'ctrl' && msg.op === 'skip') {
          wasSkipped = true;
          cleanup('you just got skipped');
          return;
        }
        if (msg.kind === 'chat') pushUserLine(msg.from || 'person', msg.text);
        else if (msg.kind === 'state') {
          remoteMicOn = !!msg.mic;
          remoteCamOn = !!msg.cam;
          updateRemoteState();
        }
      } catch {
        pushUserLine('person', String(e.data));
      }
    };
  }

  async function startCallFlow(asCaller) {
    await safeGetMedia();
    createPC(asCaller);
    if (localStream) {
      localStream.getTracks().forEach((t) => pc.addTrack(t, localStream));
      applyLocalTrackState();

      // NEW: tame bandwidth to reduce lag (no TURN needed)
      const vs = pc.getSenders().find(s => s.track && s.track.kind === 'video');
      if (vs) {
        const p = vs.getParameters();
        p.encodings = [{ maxBitrate: 300_000, maxFramerate: 24 }];
        try { await vs.setParameters(p); } catch {}
      }
      const as = pc.getSenders().find(s => s.track && s.track.kind === 'audio');
      if (as) {
        const p = as.getParameters();
        p.encodings = [{ maxBitrate: 32_000 }];
        try { await as.setParameters(p); } catch {}
      }
    }
    // don't send offer here; wait for 'ready'
    if (asCaller && peerReady && !sentOffer) {
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      await room.send({ type: 'broadcast', event: 'signal', payload: { t: 'offer', sdp: offer }});
      sentOffer = true;
    }
  }

  async function joinRoom(id, asCaller) {
    if (room) return;
    room = sb.channel(`limegle-room-${id}`, { config: { broadcast: { self: false } } });

    room.on('broadcast', { event: 'control' }, ({ payload }) => {
      if (payload.t === 'skip') {
        wasSkipped = true;
        pushSystem('you just got skipped');
        cleanup('skipped'); // NEW
      }
    });

    room.on('broadcast', { event: 'signal' }, async ({ payload }) => {
      if (!pc) return;
      if (payload.t === 'offer') {
        await pc.setRemoteDescription(payload.sdp);
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        await room.send({ type: 'broadcast', event: 'signal', payload: { t: 'answer', sdp: answer } });
      } else if (payload.t === 'answer') {
        await pc.setRemoteDescription(payload.sdp);
      } else if (payload.t === 'candidate' && payload.c) {
        try { await pc.addIceCandidate(payload.c); } catch {}
      } else if (payload.t === 'ready') {
        peerReady = true;
        if (asCaller && pc && !sentOffer) {
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          await room.send({ type: 'broadcast', event: 'signal', payload: { t: 'offer', sdp: offer }});
          sentOffer = true;
        }
      }
    });

    await room.subscribe(async (status) => {
      if (status === 'SUBSCRIBED') {
        await startCallFlow(asCaller);
    
        // announce you're ready only after the room is joined
        await room.send({
          type: 'broadcast',
          event: 'signal',
          payload: { t: 'ready' }
        });
    
        // handshake timeout (guard against duplicates)
        if (handshakeTimer) clearTimeout(handshakeTimer);
        handshakeTimer = setTimeout(() => {
          if (!dc || dc.readyState !== 'open') {
            cleanup('connection timed out');
            startMatching();
          }
        }, 8000);
      }
    });
  }

  async function cleanup(reason) {
    // Preserve current local state (these variables already persist, but we’ll
    // also re-apply them to tracks after tearing down the peer objects).
    const prevMicOn = micOn;
    const prevCamOn = camOn;
  
    // Tear down RTCPeerConnection/DataChannel/Room
    try { dc && dc.close(); } catch {}
    dc = null;
    try { pc && pc.close(); } catch {}
    pc = null;
    try { room && (await room.unsubscribe()); } catch {}
    room = null;
  
    // Reset only REMOTE UI/state
    els.remoteVideo.srcObject = null;
    els.remoteVideo.classList.remove('has-video');
    remoteMicOn = remoteCamOn = null;
  
    // General flags (do NOT touch micOn/camOn)
    peerReady = false;
    sentOffer = false;
    didRestartIce = false;
    if (retryTimer) { clearTimeout(retryTimer); retryTimer = null; }
    if (handshakeTimer) { clearTimeout(handshakeTimer); handshakeTimer = null; }
  
    // If no explicit reason and we weren't skipped, show generic message
    if (!wasSkipped && !iSkipped && !reason) reason = 'connection lost';
  
    // Re-apply preserved local track state to keep mute/camera choice
    micOn = prevMicOn;
    camOn = prevCamOn;
    if (localStream) {
      const a = localStream.getAudioTracks()[0];
      const v = localStream.getVideoTracks()[0];
      if (a) a.enabled = !!micOn;
      if (v) v.enabled = !!camOn;
    }
    updateLocalLabel();    // refresh "you (muted / camera off)" label
    updateRemoteState();   // clears remote labels
  
    if (reason) pushSystem(reason);
    wasSkipped = false;
    iSkipped = false;
    peerId = null;
  }

  // presence matching
  async function pickPartner() {
    const state = await mm.presenceState();
    const others = Object.entries(state).filter(([k]) => k !== uid);
    const waitingPeers = others
      .map(([k, v]) => ({ id: k, metas: v.metas || v }))
      .filter((it) => it.metas.some((m) => m.waiting))
      .sort((a, b) => (a.metas[0].ts || 0) - (b.metas[0].ts || 0));
    return waitingPeers.length ? waitingPeers[0].id : null;
  }

  async function onPresenceSync() {
    if (room) return;
    const partner = await pickPartner();
    if (!partner) return;
    if (shouldInvite(uid, partner)) {
      peerId = partner;
      const id = crypto.getRandomValues(new Uint32Array(1))[0].toString(36);
      await mm.send({ type: 'broadcast', event: 'invite', payload: { to: partner, from: uid, roomId: id } });
      await mm.track({ waiting: false, ts: Date.now() });
      clearChat(); // NEW: fresh chat when you invite
      await joinRoom(id, true);
    }
  }

  function shouldInvite(me, partner) {
    return String(me) > String(partner);
  }

  mm.on('broadcast', { event: 'invite' }, async ({ payload }) => {
    if (payload.to !== uid) return;
    peerId = payload.from;

    if (room) {
      if (String(payload.from) > String(uid)) {
        await cleanup();
        clearChat();
        await joinRoom(payload.roomId, false);
      }
      return;
    }

    await mm.track({ waiting: false, ts: Date.now() });
    clearChat();
    await joinRoom(payload.roomId, false);
  });

  async function startMatching() {
    await cleanup();
    clearChat();
    const partner = await pickPartner();
    if (partner) {
      if (shouldInvite(uid, partner)) {
        const id = crypto.getRandomValues(new Uint32Array(1))[0].toString(36);
        await mm.send({ type: 'broadcast', event: 'invite', payload: { to: partner, from: uid, roomId: id } });
        await mm.track({ waiting: false, ts: Date.now() });
        clearChat(); // inviter path as well
        await joinRoom(id, true);
      } else {
        await mm.track({ waiting: true, ts: Date.now() });
        pushSystem('waiting for someone…');
        onPresenceSync();
        if (!retryTimer) retryTimer = setTimeout(onPresenceSync, 1000);
      }
      return;
    }
    await mm.track({ waiting: true, ts: Date.now() });
    pushSystem('waiting for someone…');
    onPresenceSync();
    if (!retryTimer) retryTimer = setTimeout(onPresenceSync, 1000);
  }

  // UI hooks
  els.toggleMic.addEventListener('click', () => {
    if (!localStream) {
      alert('mic access is disabled in your browser. Enable permissions to use it.');
      return;
    }
    micOn = !micOn;
    applyLocalTrackState();
    sendState();
  });
  els.toggleCam.addEventListener('click', () => {
    if (!localStream) {
      alert('camera access is disabled in your browser. Enable permissions to use it.');
      return;
    }
    camOn = !camOn;
    applyLocalTrackState();
    sendState();
  });
  els.skipBtn.addEventListener('click', async () => {
    if (!pc || pc.connectionState === 'new' || pc.connectionState === 'connecting' || !els.remoteVideo.srcObject) {
      alert('no one is connected yet');
      return;
    }
    iSkipped = true;
    try {
      if (room) {
        await room.send({ type: 'broadcast', event: 'control', payload: { t: 'skip', from: uid, to: peerId } });
      }
      if (dc && dc.readyState === 'open') {
        dc.send(JSON.stringify({ kind: 'ctrl', op: 'skip' }));
      }
    } catch {}
    await cleanup('skipped');
    await startMatching();
  });

  document.getElementById('chatForm').addEventListener('submit', (e) => {
    e.preventDefault();
    const text = (els.chatText.value || '').trim();
    if (!text) return;
    pushUserLine(uid, text);
    els.chatText.value = '';
    if (dc && dc.readyState === 'open') {
      dc.send(JSON.stringify({ kind: 'chat', from: uid, text }));
    }
  });

  // overlay -> start
  const dismissJoin = () => {
    els.joinCta.style.display = 'none';
    userInteracted = true;
    if (els.remoteVideo.srcObject) {
      els.remoteVideo.muted = false;
      Promise.resolve(els.remoteVideo.play()).catch(() => {});
    }
  };
  els.joinCta.addEventListener('click', async () => {
    dismissJoin();
    await startMatching();
  });
  els.joinCta.addEventListener('keydown', async (e) => {
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      dismissJoin();
      await startMatching();
    }
  });

  // presence bootstrap
  mm.subscribe(async (status) => {
    if (status === 'SUBSCRIBED') {
      await mm.track({ waiting: false, ts: Date.now() });
      await onPresenceSync();
    }
  });

  // init media early
  (async () => {
    await safeGetMedia();
    applyLocalTrackState();
    updateRemoteState();
  })();

  // header
  document.getElementById('callLink').addEventListener('click', (e) => e.preventDefault());
  document.getElementById('helpLink').addEventListener('click', (e) => e.preventDefault());

  async function refreshOnlineCount() {
    try {
      const state = await mm.presenceState();
      // Each key is a unique user id; metas length may be >1 if they have multiple tabs.
      const count = Object.keys(state || {}).length;
      els.onlineCount.textContent = String(count);
    } catch {
      // no-op
    }
  }
  mm.on('presence', { event: 'sync'  }, refreshOnlineCount);
  mm.on('presence', { event: 'join'  }, refreshOnlineCount);
  mm.on('presence', { event: 'leave' }, refreshOnlineCount);
})();
</script>
</body>
</html>
