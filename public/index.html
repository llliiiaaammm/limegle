<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>limegle</title>
<link rel="icon" href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><text x="4" y="12">l</text></svg>'>
<script src="/env.js"></script>
<script src="https://unpkg.com/@supabase/supabase-js@2.45.4/dist/umd/supabase.js"></script>
<style>
  :root { --header-h: 48px; }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0}
  body{display:flex;flex-direction:column;font-family:monospace;color:#000;background:#fff;overflow:hidden}

  /* Header centered: call — limegle — help; id on right */
  header{
    height:var(--header-h);
    display:grid;grid-template-columns:1fr auto 1fr;
    align-items:center;padding:6px 8px;border-bottom:1px solid #000
  }
  header h1{grid-column:2;margin:0;font-size:22px;line-height:1}
  header a{justify-self:center;color:#00f;text-decoration:underline;line-height:1}
  .right-id{grid-column:3;justify-self:end;font-size:12px;line-height:1}

  /* Main layout */
  main{height:calc(100vh - var(--header-h));display:grid;grid-template-columns:2fr 1fr;gap:8px;padding:8px}
  @media (max-width:900px){ main{grid-template-columns:1fr} }

  /* Videos column: two equal rows */
  section.videos{display:grid;grid-template-rows:1fr 1fr;border-right:1px solid #000;min-height:0}
  .box{position:relative;border-bottom:1px solid #000;display:flex;flex-direction:column;min-height:0}
  .box:last-child{border-bottom:none}

  /* Video letterbox logic:
     - default: grey with loader (no stream)
     - when stream attached -> .has-video => black bars */
  video{flex:1;width:100%;height:100%;object-fit:contain;background:#ccc url('https://i.stack.imgur.com/kOnzy.gif') center/40px no-repeat}
  video.has-video{background:#000}

  .label{position:absolute;left:4px;top:2px;font-size:12px;background:#fff;padding:0 2px}
  .ribbon{position:absolute;left:4px;bottom:2px;font-size:12px;padding:0 2px}

  /* Controls on right; remote indicators are spans */
  .controls{position:absolute;right:4px;top:4px;display:flex;gap:6px;align-items:center}
  .controls span{font-size:12px;pointer-events:none}
  button{font-size:12px}

  /* Chat column */
  aside.chat{display:flex;flex-direction:column;min-height:0}
  .chat-header{border-bottom:1px solid #000;padding:4px;font-weight:bold}
  .chat-log{flex:1;overflow:auto;padding:4px;min-height:0}
  .chat-input{display:flex;gap:6px;border-top:1px solid #000;padding:4px}
  .chat-input input{flex:1;min-width:0}
  .chat-input form, .chat-input{margin:0}

  /* Join overlay */
  #joinCta{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(255,255,255,.85)}
  #joinCta .joinbox{border:1px solid #000;padding:16px 20px;background:#fff;cursor:pointer;text-align:center}

  /* header: center the group tightly, ID flush-right, all vertically centered */
  header{
    height:48px;
    display:grid;
    grid-template-columns:1fr auto 1fr;
    align-items:center;
    padding:6px 8px;
    border-bottom:1px solid #000;
  }
  .center-group{
    grid-column:2;
    justify-self:center;
    display:flex;
    align-items:center;
    gap:10px;            /* reduce or increase spacing */
  }
  .center-group h1{ margin:0; font-size:22px; line-height:1; }
  .center-group a{ color:#00f; text-decoration:underline; line-height:1; }
  .right-id{ grid-column:3; justify-self:end; font-size:12px; line-height:1; }
</style>
</head>
<body>
<header>
  <div class="center-group">
    <a href="#" id="callLink">call</a>
    <h1>limegle</h1>
    <a href="#" id="helpLink">help</a>
  </div>
  <div class="right-id">user id: <span id="userId">—</span></div>
</header>

<main>
  <!-- videos -->
  <section class="videos">
    <!-- remote -->
    <div class="box" id="remoteTile">
      <span class="label" id="remoteLabel">person</span>
      <video id="remoteVideo" autoplay playsinline></video>
      <div class="controls">
        <span id="remoteMicInd"></span>
        <span id="remoteCamInd"></span>
        <button id="skipBtn" type="button">skip</button>
      </div>
      <div class="ribbon" id="remoteRibbon"></div>
    </div>

    <!-- local -->
    <div class="box" id="localTile">
      <span class="label" id="localLabel">you</span>
      <video id="localVideo" autoplay playsinline muted></video>
      <div class="controls">
        <button id="toggleMic" type="button">mic</button>
        <button id="toggleCam" type="button">cam</button>
      </div>
      <div class="ribbon" id="localRibbon"></div>
    </div>
  </section>

  <!-- chat -->
  <aside class="chat">
    <div class="chat-header">text chat</div>
    <div id="chatLog" class="chat-log"></div>
    <form id="chatForm" class="chat-input" autocomplete="off">
      <input id="chatText" placeholder="type a message..." />
      <button type="submit">send</button>
    </form>
  </aside>
</main>

<!-- join overlay -->
<div id="joinCta" role="button" tabindex="0">
  <div class="joinbox">
    TAP TO JOIN PUBLIC CHAT
    <div style="font-size:12px;margin-top:4px">press here to call</div>
  </div>
</div>

<script>
/* global supabase, ENV */
(() => {
  // elements
  const els = {
    userId: document.getElementById('userId'),
    remoteVideo: document.getElementById('remoteVideo'),
    localVideo: document.getElementById('localVideo'),
    remoteLabel: document.getElementById('remoteLabel'),
    localLabel: document.getElementById('localLabel'),
    localRibbon: document.getElementById('localRibbon'),
    remoteRibbon: document.getElementById('remoteRibbon'),
    remoteMicInd: document.getElementById('remoteMicInd'),
    remoteCamInd: document.getElementById('remoteCamInd'),
    toggleMic: document.getElementById('toggleMic'),
    toggleCam: document.getElementById('toggleCam'),
    skipBtn: document.getElementById('skipBtn'),
    chatLog: document.getElementById('chatLog'),
    chatForm: document.getElementById('chatForm'),
    chatText: document.getElementById('chatText'),
    joinCta: document.getElementById('joinCta'),
  };

  // id
  const uid = (() => {
    const k = 'limegle_uid';
    let v = localStorage.getItem(k);
    if (!v) {
      v = (crypto.getRandomValues(new Uint32Array(1))[0] >>> 0)
        .toString(36)
        .slice(-6);
      localStorage.setItem(k, v);
    }
    return v;
  })();
  els.userId.textContent = uid;

  // supabase client
  const sb = supabase.createClient(ENV.SUPABASE_URL, ENV.SUPABASE_ANON_KEY);
  const mm = sb.channel('limegle-mm', {
    config: { presence: { key: uid }, broadcast: { self: true } },
  });

  // rtc state
  let room = null,
    roomId = null;
  let pc = null,
    dc = null,
    localStream = null;
  let micOn = true,
    camOn = true;
  let remoteMicOn = null,
    remoteCamOn = null;

  const ICE_SERVERS =
    ENV.ICE_SERVERS && ENV.ICE_SERVERS.length
      ? ENV.ICE_SERVERS
      : [{ urls: 'stun:stun.l.google.com:19302' }];

  // chat helpers
  function pushSystem(text) {
    const row = document.createElement('div');
    row.textContent = text; // no "system" label
    els.chatLog.appendChild(row);
    els.chatLog.scrollTop = els.chatLog.scrollHeight;
  }
  function pushUserLine(id, text) {
    const row = document.createElement('div');
    row.textContent = `${id}: ${text}`;
    els.chatLog.appendChild(row);
    els.chatLog.scrollTop = els.chatLog.scrollHeight;
  }
  function clearChat() {
    els.chatLog.textContent = '';
  }

  // labels: append state text
  function labelWithState(name, mic, cam) {
    const bits = [];
    if (mic === false) bits.push('muted');
    if (cam === false) bits.push('camera off');
    return bits.length ? `${name} (${bits.join(' and ')})` : name;
  }
  function updateLocalLabel() {
    els.localLabel.textContent = labelWithState('you', micOn, camOn);
    const bits = [];
    if (!micOn) bits.push('mic off');
    if (!camOn) bits.push('camera off');
    els.localRibbon.textContent = bits.join(', ');
  }
  function updateRemoteState() {
    els.remoteLabel.textContent = labelWithState(
      'person',
      remoteMicOn,
      remoteCamOn,
    );
    els.remoteMicInd.textContent =
      remoteMicOn === null ? '' : `mic: ${remoteMicOn ? 'on' : 'off'}`;
    els.remoteCamInd.textContent =
      remoteCamOn === null ? '' : `cam: ${remoteCamOn ? 'on' : 'off'}`;
    const parts = [];
    if (remoteMicOn === false) parts.push('mic off');
    if (remoteCamOn === false) parts.push('camera off');
    els.remoteRibbon.textContent = parts.join(', ');
  }

  // media
  async function safeGetMedia() {
    try {
      localStream = await navigator.mediaDevices.getUserMedia({
        audio: true,
        video: true,
      });
      els.localVideo.srcObject = localStream;
      els.localVideo.classList.add('has-video'); // black letterbox
      micOn = true;
      camOn = true;
    } catch (err) {
      // denied -> force off
      micOn = false;
      camOn = false;
      updateLocalLabel();
      pushSystem('it looks like your camera/video is blocked.');
    }
    return localStream;
  }
  function applyLocalTrackState() {
    if (!localStream) return;
    const a = localStream.getAudioTracks()[0];
    const v = localStream.getVideoTracks()[0];
    if (a) a.enabled = !!micOn;
    if (v) v.enabled = !!camOn;
    updateLocalLabel();
  }
  function sendState() {
    if (dc && dc.readyState === 'open') {
      dc.send(JSON.stringify({ kind: 'state', mic: !!micOn, cam: !!camOn }));
    }
  }

  // webrtc
  function createPC(isCaller) {
    pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });

    pc.onicecandidate = (e) => {
      if (e.candidate)
        room?.send({
          type: 'broadcast',
          event: 'signal',
          payload: { t: 'candidate', c: e.candidate },
        });
    };

    pc.ontrack = (e) => {
      els.remoteVideo.srcObject = e.streams[0];
      els.remoteVideo.classList.add('has-video'); // black bars
      // NEW: make remote playback reliable on mobile
      els.remoteVideo.muted = true;
      Promise.resolve(els.remoteVideo.play()).catch(() => {});
      remoteCamOn = true;
      updateRemoteState();
    };

    pc.onconnectionstatechange = () => {
      const s = pc.connectionState;
      if (s === 'failed' || s === 'disconnected' || s === 'closed')
        cleanup('connection ended');
    };

    if (isCaller) {
      dc = pc.createDataChannel('chat');
      attachDC();
    } else {
      pc.ondatachannel = (e) => {
        dc = e.channel;
        attachDC();
      };
    }
  }

  function attachDC() {
    dc.onopen = () => {
      sendState();
      pushSystem('connected');
    };
    dc.onmessage = (e) => {
      try {
        const msg = JSON.parse(e.data);
        if (msg.kind === 'chat') pushUserLine(msg.from || 'person', msg.text);
        else if (msg.kind === 'state') {
          remoteMicOn = !!msg.mic;
          remoteCamOn = !!msg.cam;
          updateRemoteState();
        }
      } catch {
        pushUserLine('person', String(e.data));
      }
    };
  }

  // CHANGED: proceed even if media is blocked (still create PC and negotiate)
  async function startCallFlow(asCaller) {
    await safeGetMedia();                 // may fail on phone; that's OK
    createPC(asCaller);                   // <-- always create the PC
    if (localStream) {
      localStream.getTracks().forEach((t) => pc.addTrack(t, localStream));
      applyLocalTrackState();
    }
    if (asCaller) {
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      await room.send({
        type: 'broadcast',
        event: 'signal',
        payload: { t: 'offer', sdp: offer },
      });
    }
  }

  async function joinRoom(id, asCaller) {
    if (room) return;
    room = sb.channel(`limegle-room-${id}`, {
      config: { broadcast: { self: false } },
    });

    room.on('broadcast', { event: 'signal' }, async ({ payload }) => {
      if (!pc) return;
      if (payload.t === 'offer') {
        await pc.setRemoteDescription(payload.sdp);
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        await room.send({
          type: 'broadcast',
          event: 'signal',
          payload: { t: 'answer', sdp: answer },
        });
      } else if (payload.t === 'answer') {
        await pc.setRemoteDescription(payload.sdp);
      } else if (payload.t === 'candidate' && payload.c) {
        try {
          await pc.addIceCandidate(payload.c);
        } catch {}
      }
    });

    await room.subscribe(async (status) => {
      if (status === 'SUBSCRIBED') await startCallFlow(asCaller);
    });
  }

  async function cleanup(reason) {
    try {
      dc && dc.close();
    } catch {}
    dc = null;
    try {
      pc && pc.close();
    } catch {}
    pc = null;
    try {
      room && (await room.unsubscribe());
    } catch {}
    room = null;
    els.remoteVideo.srcObject = null;
    els.remoteVideo.classList.remove('has-video'); // back to grey
    remoteMicOn = remoteCamOn = null;
    updateRemoteState();
    if (reason) pushSystem(reason);
  }

  // correct presence parsing + sorting
  async function pickPartner() {
    const state = await mm.presenceState();
    const others = Object.entries(state).filter(([k]) => k !== uid);
    const waitingPeers = others
      .map(([k, v]) => ({ id: k, metas: v.metas || v }))
      .filter((it) => it.metas.some((m) => m.waiting))
      .sort((a, b) => (a.metas[0].ts || 0) - (b.metas[0].ts || 0));
    return waitingPeers.length ? waitingPeers[0].id : null;
  }

  async function onPresenceSync() {
    if (room) return;
    const partner = await pickPartner();
    if (!partner) return;
    if (shouldInvite(uid, partner)) {
      const id = crypto.getRandomValues(new Uint32Array(1))[0].toString(36);
      await mm.send({
        type: 'broadcast',
        event: 'invite',
        payload: { to: partner, from: uid, roomId: id },
      });
      await joinRoom(id, true);
    }
  }

  // deterministic inviter: higher uid invites; lower uid waits/answers.
  function shouldInvite(me, partner) {
    return String(me) > String(partner);
  }

  mm.on('broadcast', { event: 'invite' }, async ({ payload }) => {
    if (payload.to !== uid) return;

    // If we're already in a room, tie-break:
    if (room) {
      if (String(payload.from) > String(uid)) {
        await cleanup();
        clearChat();
        await joinRoom(payload.roomId, false);
      }
      return;
    }

    await mm.track({ waiting: false, ts: Date.now() });
    clearChat();
    await joinRoom(payload.roomId, false);
  });

  async function startMatching() {
    await cleanup();
    clearChat();
    const partner = await pickPartner();
    if (partner) {
      if (shouldInvite(uid, partner)) {
        const id = crypto.getRandomValues(new Uint32Array(1))[0].toString(36);
        await mm.send({
          type: 'broadcast',
          event: 'invite',
          payload: { to: partner, from: uid, roomId: id },
        });
        await joinRoom(id, true);
      } else {
        await mm.track({ waiting: true, ts: Date.now() });
        pushSystem('waiting for someone…');
      }
      return;
    }
    await mm.track({ waiting: true, ts: Date.now() });
    pushSystem('waiting for someone…');
  }

  // UI hooks
  els.toggleMic.addEventListener('click', () => {
    if (!localStream) {
      alert('mic access is disabled in your browser. Enable permissions to use it.');
      return;
    }
    micOn = !micOn;
    applyLocalTrackState();
    sendState();
  });
  els.toggleCam.addEventListener('click', () => {
    if (!localStream) {
      alert(
        'camera access is disabled in your browser. Enable permissions to use it.',
      );
      return;
    }
    camOn = !camOn;
    applyLocalTrackState();
    sendState();
  });
  els.skipBtn.addEventListener('click', async () => {
    if (
      !pc ||
      pc.connectionState === 'new' ||
      pc.connectionState === 'connecting' ||
      !els.remoteVideo.srcObject
    ) {
      alert('no one is connected yet');
      return;
    }
    await cleanup('skipped');
    await startMatching();
  });

  // chat send
  document.getElementById('chatForm').addEventListener('submit', (e) => {
    e.preventDefault();
    const text = (els.chatText.value || '').trim();
    if (!text) return;
    pushUserLine(uid, text);
    els.chatText.value = '';
    if (dc && dc.readyState === 'open') {
      dc.send(JSON.stringify({ kind: 'chat', from: uid, text }));
    }
  });

  // overlay -> start matchmaking
  const dismissJoin = () => {
    els.joinCta.style.display = 'none';
  };
  els.joinCta.addEventListener('click', async () => {
    dismissJoin();
    await startMatching();
  });
  els.joinCta.addEventListener('keydown', async (e) => {
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      dismissJoin();
      await startMatching();
    }
  });

  // presence bootstrap
  mm.subscribe(async (status) => {
    if (status === 'SUBSCRIBED')
      await mm.track({ waiting: false, ts: Date.now() });
  });

  mm.on('presence', { event: 'sync' }, onPresenceSync);

  // init media early
  (async () => {
    await safeGetMedia();
    applyLocalTrackState();
    updateRemoteState();
  })();

  // header links inert
  document.getElementById('callLink').addEventListener('click', (e) =>
    e.preventDefault(),
  );
  document.getElementById('helpLink').addEventListener('click', (e) =>
    e.preventDefault(),
  );
})();
</script>
</body>
</html>
