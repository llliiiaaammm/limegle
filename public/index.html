<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>limegle</title>
  <!-- simple favicon to avoid 404 -->
  <link rel="icon" href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><text x="4" y="12">l</text></svg>'>
  <script src="/env.js"></script>
  <script src="https://unpkg.com/@supabase/supabase-js@2.45.4/dist/umd/supabase.js"></script>
  <style>
    html,body { margin:0; height:100%; }
    body { display:flex; flex-direction:column; font-family:monospace; }

    header { display:flex; justify-content:center; gap:20px; padding:4px; border-bottom:1px solid #000; }
    header .right-id { position:absolute; right:8px; top:4px; font-size:12px; }

    main { flex:1; display:grid; grid-template-columns:2fr 1fr; height:100%; }
    section.videos { display:grid; grid-template-rows:1fr 1fr; border-right:1px solid #000; }
    .box { position:relative; border-bottom:1px solid #000; display:flex; flex-direction:column; }
    video { flex:1; width:100%; background:#ccc url('https://i.stack.imgur.com/kOnzy.gif') center center no-repeat; background-size:40px; }
    .label { position:absolute; left:4px; top:2px; font-size:12px; background:#fff; }
    .ribbon { position:absolute; left:4px; bottom:2px; font-size:12px; }
    .controls { position:absolute; right:4px; top:4px; display:flex; gap:4px; }
    button { font-size:12px; }

    aside.chat { display:flex; flex-direction:column; }
    .chat-header { border-bottom:1px solid #000; padding:2px; font-weight:bold; }
    .chat-log { flex:1; overflow:auto; padding:4px; }
    .chat-input { display:flex; border-top:1px solid #000; }
    .chat-input input { flex:1; }

    /* Join overlay */
    #joinCta { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(255,255,255,0.8); }
    #joinCta .box { border:1px solid #000; padding:20px; background:#fff; cursor:pointer; text-align:center; }
  </style>
</head>
<body>
  <header>
    <a href="#">call</a>
    <h1>limegle</h1>
    <a href="#">help</a>
    <div class="right-id">user id: <span id="userId">â€”</span></div>
  </header>

  <main>
    <section class="videos">
      <div class="box" id="remoteTile">
        <span class="label">person</span>
        <video id="remoteVideo" autoplay playsinline></video>
        <div class="controls">
          <button id="remoteMic" disabled>mic</button>
          <button id="remoteCam" disabled>cam</button>
          <button id="skipBtn">skip</button>
        </div>
        <div class="ribbon" id="remoteRibbon"></div>
      </div>
      <div class="box" id="localTile">
        <span class="label">you</span>
        <video id="localVideo" autoplay playsinline muted></video>
        <div class="controls">
          <button id="toggleMic">mic</button>
          <button id="toggleCam">cam</button>
        </div>
        <div class="ribbon" id="localRibbon"></div>
      </div>
    </section>

    <aside class="chat">
      <div class="chat-header">text chat</div>
      <div id="chatLog" class="chat-log"></div>
      <form id="chatForm" class="chat-input">
        <input id="chatText" placeholder="type a message..." />
        <button type="submit">send</button>
      </form>
    </aside>
  </main>

  <div id="joinCta">
    <div class="box">
      TAP TO JOIN PUBLIC CHAT
      <div style="font-size:12px">press here to call</div>
    </div>
  </div>

<script>
/* global supabase, ENV */
(() => {
  // elements
  const els = {
    userId: document.getElementById('userId'),
    remoteVideo: document.getElementById('remoteVideo'),
    localVideo: document.getElementById('localVideo'),
    remoteState: document.getElementById('remoteState'),
    toggleMic: document.getElementById('toggleMic'),
    toggleCam: document.getElementById('toggleCam'),
    skipBtn: document.getElementById('skipBtn'),
    chatLog: document.getElementById('chatLog'),
    chatForm: document.getElementById('chatForm'),
    chatText: document.getElementById('chatText'),
    joinCta: document.getElementById('joinCta'),
  };

  // id
  const uid = (() => {
    const k = 'limegle_uid';
    let v = localStorage.getItem(k);
    if (!v) { v = (crypto.getRandomValues(new Uint32Array(1))[0] >>> 0).toString(36).slice(-6); localStorage.setItem(k, v); }
    return v;
  })();
  els.userId.textContent = uid;

  // supabase
  const sb = supabase.createClient(ENV.SUPABASE_URL, ENV.SUPABASE_ANON_KEY);
  const mm = sb.channel('limegle-mm', { config: { presence: { key: uid }, broadcast: { self: true } } });

  // rtc state
  let room = null, roomId = null;
  let pc = null, dc = null, localStream = null;
  let micOn = true, camOn = true;
  let remoteMicOn = null, remoteCamOn = null;

  const ICE_SERVERS = (ENV.ICE_SERVERS && ENV.ICE_SERVERS.length) ? ENV.ICE_SERVERS : [{ urls: 'stun:stun.l.google.com:19302' }];

  // chat helpers
  function pushMsg(type, who, text){
    const row = document.createElement('div'); row.className = 'msg ' + type;
    const a = document.createElement('div'); a.className = 'who'; a.textContent = who;
    const b = document.createElement('div'); b.textContent = text;
    row.appendChild(a); row.appendChild(b);
    els.chatLog.appendChild(row);
    els.chatLog.scrollTop = els.chatLog.scrollHeight;
  }
  const logSys = t => pushMsg('system','system',t);

  function updateRemoteState(){
    const m = remoteMicOn === false ? 'off' : (remoteMicOn === true ? 'on' : '?');
    const c = remoteCamOn === false ? 'off' : (remoteCamOn === true ? 'on' : '?');
    els.remoteState.textContent = `person (mic ${m}, camera ${c})`;
  }

  async function getMedia(){
    if (localStream) return localStream;
    localStream = await navigator.mediaDevices.getUserMedia({ audio:true, video:true });
    els.localVideo.srcObject = localStream;
    return localStream;
  }

  function applyLocalTrackState(){
    if (!localStream) return;
    const a = localStream.getAudioTracks()[0];
    const v = localStream.getVideoTracks()[0];
    if (a) a.enabled = !!micOn;
    if (v) v.enabled = !!camOn;
  }

  function sendState(){
    if (dc && dc.readyState === 'open') {
      dc.send(JSON.stringify({ kind:'state', mic:!!micOn, cam:!!camOn }));
    }
  }

  function createPC(isCaller){
    pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });

    pc.onicecandidate = (e) => {
      if (e.candidate) room?.send({ type:'broadcast', event:'signal', payload:{ t:'candidate', c:e.candidate } });
    };

    pc.ontrack = (e) => {
      els.remoteVideo.srcObject = e.streams[0];
      remoteCamOn = true;
      updateRemoteState();
    };

    pc.onconnectionstatechange = () => {
      const s = pc.connectionState;
      if (s === 'failed' || s === 'disconnected' || s === 'closed') cleanup('connection ended');
    };

    if (isCaller){
      dc = pc.createDataChannel('chat');
      attachDC();
    } else {
      pc.ondatachannel = (e)=>{ dc = e.channel; attachDC(); };
    }
  }

  function attachDC(){
    dc.onopen = ()=>{ sendState(); logSys('connected'); };
    dc.onmessage = (e)=>{
      try{
        const msg = JSON.parse(e.data);
        if (msg.kind === 'chat') pushMsg('peer','person',msg.text);
        else if (msg.kind === 'state'){
          remoteMicOn = !!msg.mic;
          remoteCamOn = !!msg.cam;
          updateRemoteState();
        }
      }catch{
        pushMsg('peer','person',String(e.data));
      }
    };
  }

  async function startCallFlow(asCaller){
    await getMedia();
    createPC(asCaller);
    localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
    applyLocalTrackState();
    if (asCaller){
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      await room.send({ type:'broadcast', event:'signal', payload:{ t:'offer', sdp:offer } });
    }
  }

  async function joinRoom(id, asCaller){
    if (room) return;
    roomId = id;
    room = sb.channel(`limegle-room-${id}`, { config: { broadcast: { self:false } } });

    room.on('broadcast', { event:'signal' }, async ({ payload })=>{
      if (!pc) return;
      if (payload.t === 'offer'){
        await pc.setRemoteDescription(payload.sdp);
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        await room.send({ type:'broadcast', event:'signal', payload:{ t:'answer', sdp:answer } });
      } else if (payload.t === 'answer'){
        await pc.setRemoteDescription(payload.sdp);
      } else if (payload.t === 'candidate' && payload.c){
        try{ await pc.addIceCandidate(payload.c); }catch{}
      }
    });

    await room.subscribe(async (status) => {
      if (status === 'SUBSCRIBED') await startCallFlow(asCaller);
    });
  }

  async function cleanup(reason='left'){
    try{ dc && dc.close(); }catch{} dc=null;
    try{ pc && pc.close(); }catch{} pc=null;
    try{ room && await room.unsubscribe(); }catch{} room=null;
    els.remoteVideo.srcObject = null;
    remoteMicOn = remoteCamOn = null;
    updateRemoteState();
    if (reason) logSys(reason);
  }

  async function pickPartner(){
    const state = await mm.presenceState();
    const others = Object.entries(state).filter(([k]) => k !== uid);
    const waitingPeers = others
      .map(([k,v]) => ({ id:k, metas:v }))
      .filter(it => it.metas.some(m => m.metas?.waiting))
      .sort((a,b) => (a.metas[0].metas.ts||0) - (b.metas[0].metas.ts||0));
    return waitingPeers.length ? waitingPeers[0].id : null;
  }

  mm.on('broadcast', { event:'invite' }, async ({ payload })=>{
    if (payload.to !== uid || room) return;
    await mm.track({ waiting:false, ts:Date.now() });
    await joinRoom(payload.roomId, false);
  });

  async function startMatching(){
    await cleanup('');
    const partner = await pickPartner();
    if (partner){
      const id = crypto.getRandomValues(new Uint32Array(1))[0].toString(36);
      await mm.send({ type:'broadcast', event:'invite', payload:{ to:partner, from:uid, roomId:id } });
      await joinRoom(id, true);
      return;
    }
    await mm.track({ waiting:true, ts:Date.now() });
    logSys('waiting for a personâ€¦');
  }

  // UI
  els.toggleMic.addEventListener('click', () => { micOn = !micOn; applyLocalTrackState(); sendState(); });
  els.toggleCam.addEventListener('click', () => { camOn = !camOn; applyLocalTrackState(); sendState(); });
  els.skipBtn.addEventListener('click', async () => { await cleanup('skipped'); await startMatching(); });

  const dismissJoin = ()=>{ els.joinCta.style.display='none'; };
  els.joinCta.addEventListener('click', async ()=>{ dismissJoin(); await startMatching(); });
  els.joinCta.addEventListener('keydown', async (e)=>{ if (e.key==='Enter'||e.key===' ') { e.preventDefault(); dismissJoin(); await startMatching(); } });

  // presence bootstrap
  mm.subscribe(async (status)=>{ if (status==='SUBSCRIBED') await mm.track({ waiting:false, ts:Date.now() }); });

  // get media early; plain controls
  (async () => {
    try { await getMedia(); } catch { logSys('no camera/mic permission'); micOn=false; camOn=false; }
    applyLocalTrackState();
    updateRemoteState();
  })();
})();
</script>
</body>
</html>
