<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>limegle</title>

  <!-- tiny favicon to avoid 404 -->
  <link rel="icon" href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><text x="4" y="12">l</text></svg>'>

  <!-- env + supabase -->
  <script src="/env.js"></script>
  <script src="https://unpkg.com/@supabase/supabase-js@2.45.4/dist/umd/supabase.js"></script>

  <style>
    :root { --header-h: 44px; }

    /* minimal black & white layout */
    html, body { height:100%; margin:0; }
    body { display:flex; flex-direction:column; font-family:monospace; color:#000; background:#fff; overflow:hidden; }

    /* centered header: call — limegle — help; user id right */
    header {
      height:var(--header-h);
      display:grid;
      grid-template-columns:1fr auto 1fr;
      align-items:center;
      padding:4px 8px;
      border-bottom:1px solid #000;
    }
    header h1 { grid-column:2; margin:0; font-size:22px; }
    header a { justify-self:center; color:#00f; text-decoration:underline; }
    .right-id { grid-column:3; justify-self:end; font-size:12px; }

    /* main fills viewport below header; two columns (videos 2fr, chat 1fr) */
    main {
      height:calc(100vh - var(--header-h));
      display:grid; grid-template-columns:2fr 1fr; gap:8px; padding:8px;
    }
    @media (max-width:900px) { main { grid-template-columns:1fr; } }

    /* videos column: two equal rows, no cropping */
    section.videos { display:grid; grid-template-rows:1fr 1fr; border-right:1px solid #000; min-height:0; }
    .box { position:relative; border-bottom:1px solid #000; display:flex; flex-direction:column; min-height:0; }
    .box:last-child { border-bottom:none; }

    video {
      flex:1; width:100%; height:100%;
      object-fit:contain;                    /* no cut-off */
      background:#ccc url('https://i.stack.imgur.com/kOnzy.gif') center/40px no-repeat; /* grey with loader */
    }

    .label { position:absolute; left:4px; top:2px; font-size:12px; background:#fff; }
    .ribbon { position:absolute; left:4px; bottom:2px; font-size:12px; }

    /* controls on right; remote indicators are spans (read-only) */
    .controls { position:absolute; right:4px; top:4px; display:flex; gap:6px; align-items:center; }
    .controls span { font-size:12px; pointer-events:none; }
    button { font-size:12px; }

    /* chat column uses full height; input pinned bottom; no extra space */
    aside.chat { display:flex; flex-direction:column; min-height:0; }
    .chat-header { border-bottom:1px solid #000; padding:4px; font-weight:bold; }
    .chat-log { flex:1; overflow:auto; padding:4px; min-height:0; }
    .chat-input { display:flex; gap:6px; border-top:1px solid #000; padding:4px; }
    .chat-input input { flex:1; min-width:0; }

    /* join overlay */
    #joinCta { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(255,255,255,.85); }
    #joinCta .joinbox { border:1px solid #000; padding:16px 20px; background:#fff; cursor:pointer; text-align:center; }
  </style>
</head>
<body>
  <header>
    <a href="#" id="callLink">call</a>
    <h1>limegle</h1>
    <a href="#" id="helpLink">help</a>
    <div class="right-id">user id: <span id="userId">—</span></div>
  </header>

  <main>
    <!-- videos -->
    <section class="videos">
      <!-- remote -->
      <div class="box" id="remoteTile">
        <span class="label">person</span>
        <video id="remoteVideo" autoplay playsinline></video>
        <div class="controls">
          <span id="remoteMicInd"></span>
          <span id="remoteCamInd"></span>
          <button id="skipBtn" type="button">skip</button>
        </div>
        <div class="ribbon" id="remoteRibbon"></div>
      </div>

      <!-- local -->
      <div class="box" id="localTile">
        <span class="label">you</span>
        <video id="localVideo" autoplay playsinline muted></video>
        <div class="controls">
          <button id="toggleMic" type="button">mic</button>
          <button id="toggleCam" type="button">cam</button>
        </div>
        <div class="ribbon" id="localRibbon"></div>
      </div>
    </section>

    <!-- chat -->
    <aside class="chat">
      <div class="chat-header">text chat</div>
      <div id="chatLog" class="chat-log"></div>
      <form id="chatForm" class="chat-input" autocomplete="off">
        <input id="chatText" placeholder="type a message..." />
        <button type="submit">send</button>
      </form>
    </aside>
  </main>

  <!-- join overlay -->
  <div id="joinCta" role="button" tabindex="0">
    <div class="joinbox">
      TAP TO JOIN PUBLIC CHAT
      <div style="font-size:12px;margin-top:4px">press here to call</div>
    </div>
  </div>

<script>
/* global supabase, ENV */
(() => {
  // elements
  const els = {
    userId: document.getElementById('userId'),
    remoteVideo: document.getElementById('remoteVideo'),
    localVideo: document.getElementById('localVideo'),
    remoteRibbon: document.getElementById('remoteRibbon'),
    remoteMicInd: document.getElementById('remoteMicInd'),
    remoteCamInd: document.getElementById('remoteCamInd'),
    toggleMic: document.getElementById('toggleMic'),
    toggleCam: document.getElementById('toggleCam'),
    skipBtn: document.getElementById('skipBtn'),
    chatLog: document.getElementById('chatLog'),
    chatForm: document.getElementById('chatForm'),
    chatText: document.getElementById('chatText'),
    joinCta: document.getElementById('joinCta'),
  };

  // id
  const uid = (() => {
    const k = 'limegle_uid';
    let v = localStorage.getItem(k);
    if (!v) { v = (crypto.getRandomValues(new Uint32Array(1))[0] >>> 0).toString(36).slice(-6); localStorage.setItem(k, v); }
    return v;
  })();
  els.userId.textContent = uid;

  // supabase client
  const sb = supabase.createClient(ENV.SUPABASE_URL, ENV.SUPABASE_ANON_KEY);
  const mm = sb.channel('limegle-mm', { config: { presence: { key: uid }, broadcast: { self: true } } });

  // rtc state
  let room = null, roomId = null;
  let pc = null, dc = null, localStream = null;
  let micOn = true, camOn = true;
  let remoteMicOn = null, remoteCamOn = null;

  const ICE_SERVERS = (ENV.ICE_SERVERS && ENV.ICE_SERVERS.length) ? ENV.ICE_SERVERS : [{ urls: 'stun:stun.l.google.com:19302' }];

  // helpers
  function pushMsg(type, who, text){
    const row = document.createElement('div'); row.className = 'msg ' + type;
    const a = document.createElement('div'); a.className = 'who'; a.textContent = who;
    const b = document.createElement('div'); b.textContent = text;
    row.appendChild(a); row.appendChild(b);
    els.chatLog.appendChild(row);
    els.chatLog.scrollTop = els.chatLog.scrollHeight;
  }
  const logSys = t => pushMsg('system', 'system', t);

  function updateRemoteState(){
    // build parts only for known values (no '?')
    const parts = [];
    if (remoteMicOn !== null) parts.push(`mic ${remoteMicOn ? 'on' : 'off'}`);
    if (remoteCamOn !== null) parts.push(`camera ${remoteCamOn ? 'on' : 'off'}`);
    els.remoteRibbon.textContent = parts.join(', ');
    els.remoteMicInd.textContent = (remoteMicOn === null) ? '' : `mic: ${remoteMicOn ? 'on' : 'off'}`;
    els.remoteCamInd.textContent = (remoteCamOn === null) ? '' : `cam: ${remoteCamOn ? 'on' : 'off'}`;
  }

  async function getMedia(){
    if (localStream) return localStream;
    localStream = await navigator.mediaDevices.getUserMedia({ audio:true, video:true });
    els.localVideo.srcObject = localStream;
    return localStream;
  }

  function applyLocalTrackState(){
    if (!localStream) return;
    const a = localStream.getAudioTracks()[0];
    const v = localStream.getVideoTracks()[0];
    if (a) a.enabled = !!micOn;
    if (v) v.enabled = !!camOn;
    // local ribbon text
    const bits = [];
    if (!micOn) bits.push('mic off');
    if (!camOn) bits.push('camera off');
    document.getElementById('localRibbon').textContent = bits.join(', ');
  }

  function sendState(){
    if (dc && dc.readyState === 'open') {
      dc.send(JSON.stringify({ kind:'state', mic:!!micOn, cam:!!camOn }));
    }
  }

  function createPC(isCaller){
    pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });

    pc.onicecandidate = (e) => {
      if (e.candidate) room?.send({ type:'broadcast', event:'signal', payload:{ t:'candidate', c:e.candidate } });
    };

    pc.ontrack = (e) => {
      els.remoteVideo.srcObject = e.streams[0];
      remoteCamOn = true;
      updateRemoteState();
    };

    pc.onconnectionstatechange = () => {
      const s = pc.connectionState;
      if (s === 'failed' || s === 'disconnected' || s === 'closed') cleanup('connection ended');
    };

    if (isCaller){
      dc = pc.createDataChannel('chat');
      attachDC();
    } else {
      pc.ondatachannel = (e)=>{ dc = e.channel; attachDC(); };
    }
  }

  function attachDC(){
    dc.onopen = ()=>{ sendState(); logSys('connected'); };
    dc.onmessage = (e)=>{
      try{
        const msg = JSON.parse(e.data);
        if (msg.kind === 'chat') pushMsg('peer','person',msg.text);
        else if (msg.kind === 'state'){
          remoteMicOn = !!msg.mic;
          remoteCamOn = !!msg.cam;
          updateRemoteState();
        }
      }catch{
        pushMsg('peer','person',String(e.data));
      }
    };
  }

  async function startCallFlow(asCaller){
    await getMedia();
    createPC(asCaller);
    localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
    applyLocalTrackState();
    if (asCaller){
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      await room.send({ type:'broadcast', event:'signal', payload:{ t:'offer', sdp:offer } });
    }
  }

  async function joinRoom(id, asCaller){
    if (room) return;
    roomId = id;
    room = sb.channel(`limegle-room-${id}`, { config: { broadcast: { self:false } } });

    room.on('broadcast', { event:'signal' }, async ({ payload })=>{
      if (!pc) return;
      if (payload.t === 'offer'){
        await pc.setRemoteDescription(payload.sdp);
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        await room.send({ type:'broadcast', event:'signal', payload:{ t:'answer', sdp:answer } });
      } else if (payload.t === 'answer'){
        await pc.setRemoteDescription(payload.sdp);
      } else if (payload.t === 'candidate' && payload.c){
        try{ await pc.addIceCandidate(payload.c); }catch{}
      }
    });

    await room.subscribe(async (status) => {
      if (status === 'SUBSCRIBED') await startCallFlow(asCaller);
    });
  }

  async function cleanup(reason='left'){
    try{ dc && dc.close(); }catch{} dc=null;
    try{ pc && pc.close(); }catch{} pc=null;
    try{ room && await room.unsubscribe(); }catch{} room=null;
    els.remoteVideo.srcObject = null;
    remoteMicOn = remoteCamOn = null;
    updateRemoteState();
    if (reason) logSys(reason);
  }

  async function pickPartner(){
    const state = await mm.presenceState();
    const others = Object.entries(state).filter(([k]) => k !== uid);
    const waitingPeers = others
      .map(([k,v]) => ({ id:k, metas:v }))
      .filter(it => it.metas.some(m => m.metas?.waiting))
      .sort((a,b) => (a.metas[0].metas.ts||0) - (b.metas[0].metas.ts||0));
    return waitingPeers.length ? waitingPeers[0].id : null;
  }

  mm.on('broadcast', { event:'invite' }, async ({ payload })=>{
    if (payload.to !== uid || room) return;
    await mm.track({ waiting:false, ts:Date.now() });
    await joinRoom(payload.roomId, false);
  });

  async function startMatching(){
    await cleanup('');
    const partner = await pickPartner();
    if (partner){
      const id = crypto.getRandomValues(new Uint32Array(1))[0].toString(36);
      await mm.send({ type:'broadcast', event:'invite', payload:{ to:partner, from:uid, roomId:id } });
      await joinRoom(id, true);
      return;
    }
    await mm.track({ waiting:true, ts:Date.now() });
    logSys('waiting for someone…');
  }

  // UI
  els.toggleMic.addEventListener('click', () => { micOn = !micOn; applyLocalTrackState(); sendState(); });
  els.toggleCam.addEventListener('click', () => { camOn = !camOn; applyLocalTrackState(); sendState(); });
  els.skipBtn.addEventListener('click', async () => { await cleanup('skipped'); await startMatching(); });

  // overlay -> start matchmaking
  const dismissJoin = ()=>{ els.joinCta.style.display='none'; };
  els.joinCta.addEventListener('click', async ()=>{ dismissJoin(); await startMatching(); });
  els.joinCta.addEventListener('keydown', async (e)=>{ if (e.key==='Enter'||e.key===' ') { e.preventDefault(); dismissJoin(); await startMatching(); } });

  // presence bootstrap
  mm.subscribe(async (status)=>{ if (status==='SUBSCRIBED') await mm.track({ waiting:false, ts:Date.now() }); });

  // get media early; set initial ribbons/indicators
  (async () => {
    try { await getMedia(); } catch { logSys('no camera/mic permission'); micOn=false; camOn=false; }
    applyLocalTrackState();
    updateRemoteState();
  })();

  // header links are inert for now
  document.getElementById('callLink').addEventListener('click', e => e.preventDefault());
  document.getElementById('helpLink').addEventListener('click', e => e.preventDefault());
})();
</script>
</body>
</html>
