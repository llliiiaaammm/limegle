<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>limegle</title>
  <!-- simple favicon to avoid 404 -->
  <link rel="icon" href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><text x="4" y="12">l</text></svg>'>
  <script src="/env.js"></script>
  <script src="https://unpkg.com/@supabase/supabase-js@2.45.4/dist/umd/supabase.js"></script>
  <style>
    /* minimal, black & white */
    html,body{margin:0;padding:0}
    .topbar{display:grid;grid-template-columns:1fr auto 1fr;align-items:center;padding:8px 10px;border-bottom:1px solid #000}
    .center-group{grid-column:2;display:flex;align-items:center;gap:8px}
    .brand{margin:0;font-size:28px;font-weight:bold;text-transform:lowercase}
    .link{color:#000;text-decoration:underline;text-transform:lowercase}
    .right-id{grid-column:3;justify-self:end}
    .layout{display:grid;grid-template-columns:1fr 320px;gap:10px;padding:10px}
    @media (max-width:900px){.layout{grid-template-columns:1fr}}
    .section{border:1px solid #000;padding:8px}
    video{width:100%;height:auto;background:#000}
    .controls{margin:6px 0;display:flex;gap:6px}
    .chat-log{height:240px;overflow:auto;border:1px solid #000;padding:6px}
    .msg{display:flex;gap:6px;margin:4px 0}
    .msg.system{justify-content:center}
    .msg.system .who{display:none}
    .chat-input{display:flex;gap:6px;margin-top:6px}
    .join-cta{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.1)}
    .join-bar{width:100%;max-width:900px;padding:10px 12px;border:1px solid #000;background:#fff;text-align:center;cursor:pointer}
  </style>
</head>
<body>
  <header class="topbar">
    <div></div>
    <div class="center-group">
      <a href="#" class="link" id="callLink">call</a>
      <h1 class="brand">limegle</h1>
      <a href="#" class="link" id="helpLink">help</a>
    </div>
    <div class="right-id">user id: <span id="userId">—</span></div>
  </header>

  <main class="layout">
    <section class="section">
      <div>person</div>
      <video id="remoteVideo" autoplay playsinline></video>
      <div id="remoteState">person (mic ?, camera ?)</div>

      <hr>

      <div>you</div>
      <video id="localVideo" autoplay playsinline muted></video>
      <div class="controls">
        <button id="toggleMic">toggle mic</button>
        <button id="toggleCam">toggle camera</button>
        <button id="skipBtn">skip</button>
      </div>
    </section>

    <aside class="section">
      <div>text chat</div>
      <div id="chatLog" class="chat-log"></div>
      <form id="chatForm" class="chat-input" autocomplete="off">
        <input id="chatText" placeholder="type a message..." />
        <button type="submit">send</button>
      </form>
    </aside>
  </main>

  <!-- join CTA -->
  <div id="joinCta" class="join-cta" role="button" tabindex="0">
    <div class="join-bar">
      TAP TO JOIN PUBLIC CHAT
      <div>press here to call</div>
    </div>
  </div>

<script>
/* global supabase, ENV */
(() => {
  // elements
  const els = {
    userId: document.getElementById('userId'),
    remoteVideo: document.getElementById('remoteVideo'),
    localVideo: document.getElementById('localVideo'),
    remoteState: document.getElementById('remoteState'),
    toggleMic: document.getElementById('toggleMic'),
    toggleCam: document.getElementById('toggleCam'),
    skipBtn: document.getElementById('skipBtn'),
    chatLog: document.getElementById('chatLog'),
    chatForm: document.getElementById('chatForm'),
    chatText: document.getElementById('chatText'),
    joinCta: document.getElementById('joinCta'),
  };

  // id
  const uid = (() => {
    const k = 'limegle_uid';
    let v = localStorage.getItem(k);
    if (!v) { v = (crypto.getRandomValues(new Uint32Array(1))[0] >>> 0).toString(36).slice(-6); localStorage.setItem(k, v); }
    return v;
  })();
  els.userId.textContent = uid;

  // supabase
  const sb = supabase.createClient(ENV.SUPABASE_URL, ENV.SUPABASE_ANON_KEY);
  const mm = sb.channel('limegle-mm', { config: { presence: { key: uid }, broadcast: { self: true } } });

  // rtc state
  let room = null, roomId = null;
  let pc = null, dc = null, localStream = null;
  let micOn = true, camOn = true;
  let remoteMicOn = null, remoteCamOn = null;

  const ICE_SERVERS = (ENV.ICE_SERVERS && ENV.ICE_SERVERS.length) ? ENV.ICE_SERVERS : [{ urls: 'stun:stun.l.google.com:19302' }];

  // chat helpers
  function pushMsg(type, who, text){
    const row = document.createElement('div'); row.className = 'msg ' + type;
    const a = document.createElement('div'); a.className = 'who'; a.textContent = who;
    const b = document.createElement('div'); b.textContent = text;
    row.appendChild(a); row.appendChild(b);
    els.chatLog.appendChild(row);
    els.chatLog.scrollTop = els.chatLog.scrollHeight;
  }
  const logSys = t => pushMsg('system','system',t);

  function updateRemoteState(){
    const m = remoteMicOn === false ? 'off' : (remoteMicOn === true ? 'on' : '?');
    const c = remoteCamOn === false ? 'off' : (remoteCamOn === true ? 'on' : '?');
    els.remoteState.textContent = `person (mic ${m}, camera ${c})`;
  }

  async function getMedia(){
    if (localStream) return localStream;
    localStream = await navigator.mediaDevices.getUserMedia({ audio:true, video:true });
    els.localVideo.srcObject = localStream;
    return localStream;
  }

  function applyLocalTrackState(){
    if (!localStream) return;
    const a = localStream.getAudioTracks()[0];
    const v = localStream.getVideoTracks()[0];
    if (a) a.enabled = !!micOn;
    if (v) v.enabled = !!camOn;
  }

  function sendState(){
    if (dc && dc.readyState === 'open') {
      dc.send(JSON.stringify({ kind:'state', mic:!!micOn, cam:!!camOn }));
    }
  }

  function createPC(isCaller){
    pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });

    pc.onicecandidate = (e) => {
      if (e.candidate) room?.send({ type:'broadcast', event:'signal', payload:{ t:'candidate', c:e.candidate } });
    };

    pc.ontrack = (e) => {
      els.remoteVideo.srcObject = e.streams[0];
      remoteCamOn = true;
      updateRemoteState();
    };

    pc.onconnectionstatechange = () => {
      const s = pc.connectionState;
      if (s === 'failed' || s === 'disconnected' || s === 'closed') cleanup('connection ended');
    };

    if (isCaller){
      dc = pc.createDataChannel('chat');
      attachDC();
    } else {
      pc.ondatachannel = (e)=>{ dc = e.channel; attachDC(); };
    }
  }

  function attachDC(){
    dc.onopen = ()=>{ sendState(); logSys('connected'); };
    dc.onmessage = (e)=>{
      try{
        const msg = JSON.parse(e.data);
        if (msg.kind === 'chat') pushMsg('peer','person',msg.text);
        else if (msg.kind === 'state'){
          remoteMicOn = !!msg.mic;
          remoteCamOn = !!msg.cam;
          updateRemoteState();
        }
      }catch{
        pushMsg('peer','person',String(e.data));
      }
    };
  }

  async function startCallFlow(asCaller){
    await getMedia();
    createPC(asCaller);
    localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
    applyLocalTrackState();
    if (asCaller){
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      await room.send({ type:'broadcast', event:'signal', payload:{ t:'offer', sdp:offer } });
    }
  }

  async function joinRoom(id, asCaller){
    if (room) return;
    roomId = id;
    room = sb.channel(`limegle-room-${id}`, { config: { broadcast: { self:false } } });

    room.on('broadcast', { event:'signal' }, async ({ payload })=>{
      if (!pc) return;
      if (payload.t === 'offer'){
        await pc.setRemoteDescription(payload.sdp);
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        await room.send({ type:'broadcast', event:'signal', payload:{ t:'answer', sdp:answer } });
      } else if (payload.t === 'answer'){
        await pc.setRemoteDescription(payload.sdp);
      } else if (payload.t === 'candidate' && payload.c){
        try{ await pc.addIceCandidate(payload.c); }catch{}
      }
    });

    await room.subscribe(async (status) => {
      if (status === 'SUBSCRIBED') await startCallFlow(asCaller);
    });
  }

  async function cleanup(reason='left'){
    try{ dc && dc.close(); }catch{} dc=null;
    try{ pc && pc.close(); }catch{} pc=null;
    try{ room && await room.unsubscribe(); }catch{} room=null;
    els.remoteVideo.srcObject = null;
    remoteMicOn = remoteCamOn = null;
    updateRemoteState();
    if (reason) logSys(reason);
  }

  async function pickPartner(){
    const state = await mm.presenceState();
    const others = Object.entries(state).filter(([k]) => k !== uid);
    const waitingPeers = others
      .map(([k,v]) => ({ id:k, metas:v }))
      .filter(it => it.metas.some(m => m.metas?.waiting))
      .sort((a,b) => (a.metas[0].metas.ts||0) - (b.metas[0].metas.ts||0));
    return waitingPeers.length ? waitingPeers[0].id : null;
  }

  mm.on('broadcast', { event:'invite' }, async ({ payload })=>{
    if (payload.to !== uid || room) return;
    await mm.track({ waiting:false, ts:Date.now() });
    await joinRoom(payload.roomId, false);
  });

  async function startMatching(){
    await cleanup('');
    const partner = await pickPartner();
    if (partner){
      const id = crypto.getRandomValues(new Uint32Array(1))[0].toString(36);
      await mm.send({ type:'broadcast', event:'invite', payload:{ to:partner, from:uid, roomId:id } });
      await joinRoom(id, true);
      return;
    }
    await mm.track({ waiting:true, ts:Date.now() });
    logSys('waiting for a person…');
  }

  // UI
  els.toggleMic.addEventListener('click', () => { micOn = !micOn; applyLocalTrackState(); sendState(); });
  els.toggleCam.addEventListener('click', () => { camOn = !camOn; applyLocalTrackState(); sendState(); });
  els.skipBtn.addEventListener('click', async () => { await cleanup('skipped'); await startMatching(); });

  const dismissJoin = ()=>{ els.joinCta.style.display='none'; };
  els.joinCta.addEventListener('click', async ()=>{ dismissJoin(); await startMatching(); });
  els.joinCta.addEventListener('keydown', async (e)=>{ if (e.key==='Enter'||e.key===' ') { e.preventDefault(); dismissJoin(); await startMatching(); } });

  // presence bootstrap
  mm.subscribe(async (status)=>{ if (status==='SUBSCRIBED') await mm.track({ waiting:false, ts:Date.now() }); });

  // get media early; plain controls
  (async () => {
    try { await getMedia(); } catch { logSys('no camera/mic permission'); micOn=false; camOn=false; }
    applyLocalTrackState();
    updateRemoteState();
  })();
})();
</script>
</body>
</html>
